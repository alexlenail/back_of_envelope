{
  
    
        "post0": {
            "title": "Enzyme Kinetic Parameter Inference",
            "content": "# imports from itertools import combinations_with_replacement, product from collections import Counter from io import StringIO import numpy as np import pandas as pd import matplotlib.pyplot as plt import matplotlib.ticker as mtick import scipy.stats import seaborn as sns from scipy.stats import multivariate_normal from scipy.interpolate import interp1d from scipy.stats.kde import gaussian_kde from sklearn.linear_model import LinearRegression from sklearn.gaussian_process.kernels import Matern import ipywidgets as widgets from IPython.display import display %config InlineBackend.figure_format = &#39;retina&#39; %matplotlib inline plt.rcParams[&#39;figure.figsize&#39;] = [12, 5] plt.rcParams[&#39;figure.dpi&#39;] = 140 plt.rcParams[&#39;agg.path.chunksize&#39;] = 10000 %load_ext jupyternotify import os # os.system(&quot;printf &#39; a&#39;&quot;) # or &#39; 7&#39; exp = np.exp sin = np.sin cos = np.cos sqrt = np.sqrt Π = np.prod π = np.pi N = np.random.normal def is_power_of_2(x): return x &gt; 4 and (x &amp; (x-1) == 0) . The jupyternotify extension is already loaded. To reload it, use: %reload_ext jupyternotify . # simple matrix view macro import PIL.Image from matplotlib.pyplot import imshow def show(*Ms): fig, axs = plt.subplots(ncols=len(Ms)) for M, ax in zip(Ms, (axs if type(axs) == list else [axs])): M = np.atleast_2d(M) ax.imshow(PIL.Image.fromarray((M - M.min()) * 255 / M.max())) ax.set_xticks([0, M.shape[1]]) ax.set_yticks([0, M.shape[0]]) for side in [&quot;right&quot;,&quot;top&quot;,&quot;bottom&quot;,&quot;left&quot;]: ax.spines[side].set_visible(False) return fig, axs . # simple distrib pdf view macro from scipy.stats import weibull_min, dweibull, dgamma, expon as exponential from scipy.stats import rv_discrete, rv_continuous def is_discrete(dist): if hasattr(dist, &#39;dist&#39;): return isinstance(dist.dist, rv_discrete) else: return isinstance(dist, rv_discrete) def is_continuous(dist): if hasattr(dist, &#39;dist&#39;): return isinstance(dist.dist, rv_continuous) else: return isinstance(dist, rv_continuous) def plot_distrib(distrib, title=None): fig, ax = plt.subplots(1, 1) if is_continuous(distrib): x = np.linspace(distrib.ppf(0.01), distrib.ppf(0.99), 100) ax.plot(x, distrib.pdf(x), &#39;k-&#39;, lw=0.4) elif is_discrete(distrib): x = np.arange(distrib.ppf(0.01), distrib.ppf(0.99)) ax.plot(x, distrib.pmf(x), &#39;bo&#39;, ms=2, lw=0.4) r = distrib.rvs(size=1000) ax.hist(r, density=True, histtype=&#39;stepfilled&#39;, alpha=0.2, bins=100) if title: ax.set_title(title) return ax . 1. Background . $$ newcommand{ kon}{k_{ mathrm{on}}} newcommand{ koff}{k_{ mathrm{off}}} newcommand{ kcat}{k_{ mathrm{cat}}} newcommand{ kuncat}{k_{ mathrm{uncat}}} newcommand{ dSdt}{ frac{d[ mathrm{S}]}{dt}} newcommand{ dEdt}{ frac{d[ mathrm{E}]}{dt}} newcommand{ dESdt}{ frac{d[ mathrm{ES}]}{dt}} newcommand{ dPdt}{ frac{d[ mathrm{P}]}{dt}}$$1.1 Enzyme Kinetics . Enzymes catalyze many critical chemical reactions in cells. . Describing a cell with a mathematical model (a long-standing goal of computational biologists) would entail modelling each enzyme-catalyzed chemical reaction. . However, although we may know the scheme for many enzymatic reactions (the responsible enzyme, the associated substrates, and resultant reaction products) we are often missing many of the details needed to construct a faithful mathematical model of the reaction. . Let&#39;s begin by introducing the mathematical model used to describe enzymatic reaction schemes. Consider the following enzymatically-catalyzed (uni uni) chemical reaction scheme: . $$ E+S underset{ koff}{ overset{ kon}{ rightleftarrows}} ES underset{ kuncat}{ overset{ kcat}{ rightleftarrows}}E+P $$ . In this scheme E is an enzyme, S is its substrate, ES is the enzyme-substrate complex, which is an intermediate, and P is the product of the reaction. Each of those chemical species has a concentration in a fixed volume, which we denote with brackets (e.g. [E] = enzyme concentration). . If we make the simplifying assumption that the 4 molecular species are &#39;well-mixed&#39; in solution, we can invoke the &#39;Law of Mass Action&#39; under which the rate of each of the four included reactions is linear in the concentrations of the reactants (with an associated rate constant coefficient). The reactions in the above scheme are: enzyme-substrate association ($ kon$), dissociation ($ koff$), enzyme catalysis of substrate into product ($ kcat$), and enzyme-product re-association (&quot;uncatalysis&quot;, $ kuncat$). The &#39;direction&#39; of the reaction, and the designation of &#39;substrate&#39; and &#39;product&#39; is our choice -- the model is entirely symmetric, which is reflected in the associated ODEs: . $$ begin{aligned} frac{d[ mathrm{S}]}{dt} &amp;= k_{ mathrm{off}}[ mathrm{ES}] - k_{ mathrm{on}}[ mathrm{E}][ mathrm{S}] frac{d[ mathrm{E}]}{dt} &amp;= k_{ mathrm{off}}[ mathrm{ES}] - k_{ mathrm{on}}[ mathrm{E}][ mathrm{S}] + k_{ mathrm{cat}}[ mathrm{ES}] - k_{ mathrm{uncat}}[ mathrm{E}][ mathrm{P}] frac{d[ mathrm{ES}]}{dt} &amp;= - k_{ mathrm{off}}[ mathrm{ES}] + k_{ mathrm{on}}[ mathrm{E}][ mathrm{S}] - k_{ mathrm{cat}}[ mathrm{ES}] + k_{ mathrm{uncat}}[ mathrm{E}][ mathrm{P}] frac{d[ mathrm{P}]}{dt} &amp;= k_{ mathrm{cat}}[ mathrm{ES}] - k_{ mathrm{uncat}}[ mathrm{E}][ mathrm{P}] end{aligned}$$This differential equation model describing the (deterministic) chemical kinetics for an enzymatically-catalyzed reaction in well-mixed conditions contains 4 kinetic parameters, i.e. 4 degrees of freedom, which we do not know a priori. These will be the subject of inference. . Note: the intracellular environment is not best described as well-mixed, and models of &#8217;Macromolecular Crowding&#8217; have led to more accurate rate laws for these reactions in vivo. However, we will retain the well-mixed assumption for now. . 1.2 Parameter Inference . There are 3 typical problems associated with ODE models: . Supplied with a complete specification of the system, the forward problem is to integrate the differential equations from some initial conditions forwards in time and predict the trajectory of the system. This is what is typically meant by &quot;solving&quot; the ODE system, but exact analytical solutions are rare, and numerical methods are often brought to bear to approximate system trajectories. | Supplied with one or more trajectories (data) but incomplete specification of the system, the inverse problem is to estimate parameters of the system (coefficients in the ODE expressions). | Finally, given some manipulable inputs, the control problem is to drive the system towards some desired state. | . This post will explore a range of approaches for the inverse problem. Our goal will be to estimate the kinetic parameters of enzymatically-catalyzed chemical reactions from timeseries of concentrations of the molecular species. . Note: enzyme kinetic parameters are typically not inferred from metabolite timeseries data using the methods we will describe, but instead from specific enzyme assays. However, at the moment, these assays are limited to studying one enzyme at a time. The inference approaches described in this post can leverage data from emerging high-throughput assays. . The determination of the kinetic parameters for the enzymatic reactions of life is a major project, and reported values have been tabulated in databases such as BRENDA. However, my experience with these databases has been that the reported kinetic parameters appear to be severely unreliable. . 1.3 The Michaelis-Menten/Briggs-Haldane Approximation . Two assumptions commonly made at this point are: . to suppose that the rates of enzyme-substrate association ($ kon$) and dissociation ($ koff$) are greater than the rates for enzyme and product ($ kon$, $ koff$ $ gg$ $ kcat$, $ kuncat$). | to assume the initial substrate concentration is much larger than the enzyme concentration ($[ mathrm{S_0}] &gt; [ mathrm{E_0}]$). These assumptions permit a timescale separation argument called the &quot;Quasi-Steady-State Approximation&quot; (QSSA) permits us to set $ dESdt = 0$. From this approximation, we can derive the traditional Reversible Michaelis-Menten/Briggs-Haldane expression: | . $$ begin{aligned} frac{d[ mathrm{P}]}{dt} &amp;= frac{ frac{ kcat , [ mathrm{E_T}] [ mathrm{S}]}{K_{m, mathrm{S}}} - frac{ koff , [ mathrm{E_T}] [ mathrm{P}]}{K_{m, mathrm{P}}}} {1+ frac{[ mathrm{S}]}{K_{m, mathrm{S}}} + frac{[ mathrm{P}]}{K_{m, mathrm{P}}}} frac{d[ mathrm{S}]}{dt} &amp;= - frac{d[ mathrm{P}]}{dt} end{aligned}$$in which we have introduced the &quot;Michaelis Constants&quot;: $K_{m, mathrm{S}} = frac{ koff + kcat}{ kon}$ and $K_{m, mathrm{P}} = frac{ kcat + koff}{ kuncat}$. . The QSSA reduces the system from 4 variables to 2. There are still 4 kinetic parameters to estimate in this reduced model. . Note: another assumption typically made at this point is to assume that catalysis is irreversible, leading to a further simplified expression for the rate of product formation $ frac{d[ mathrm{P}]}{dt}$. However, this assumption is quite often inaccurate, so we will not make it. . 2. Exploring the Forward Model . Before we explore techniques to estimate enzyme kinetic parameters from timeseries data, we need to generate timeseries data from the model to begin with, i.e. we need to solve the forward problem, given kinetic parameters. It will turn out that integrating the model forwards is a subroutine of both approaches to the inverse problem we&#39;ll see in this post. . For our first go, let&#39;s first use some generic rate constants: . $ kon ,$ of $10^6$ events per Mol per second, or 1 per μM per second, is a typical rate for enzyme-substrate binding. | $ koff ,$ of 100/s results in a $ koff$/$ kon$ = $k_d$ of 100 μM, which is a typical $k_d$. | $ kcat ,$ is 100/s, a respectable $ kcat$. | $ kuncat ,$ of $ frac{ kon}{10}$ is often considered as boundary for the QSSA to hold (so 0.1 per μM per second). | . Calculations will be performed in μM and seconds. . k_on = 1 k_off = 100 k_cat = 100 k_uncat = 0.1 k_ms = (k_off + k_cat) / k_on k_mp = (k_off + k_cat) / k_uncat kinetic_params = {&#39;k_on&#39;:k_on, &#39;k_off&#39;:k_off, &#39;k_cat&#39;:k_cat, &#39;k_uncat&#39;:k_uncat, &#39;k_ms&#39;:k_ms, &#39;k_mp&#39;:k_mp} . There are a variety of numerical methods to integrate systems of differential equations. The most straightforward is Euler&#39;s method, which we&#39;ve written down explicitly for this system below: . def euler_full(E_0, S_0, dt, steps, **kinetic_params): S = S_0 E = E_0 ES = 0 P = 0 # k_on, k_off, k_cat, k_uncat, k_ms, k_mp = **kinetic_params traj = [[S, E, ES, P]] for _ in range(int(steps)): dSdt = k_off * ES - k_on * E * S dEdt = k_off * ES - k_on * E * S + k_cat * ES - k_uncat * E * P dESdt = k_on * E * S - k_off * ES - k_cat * ES + k_uncat * E * P dPdt = k_cat * ES - k_uncat * E * P S += dSdt * dt E += dEdt * dt ES += dESdt * dt P += dPdt * dt traj.append([S, E, ES, P]) return pd.DataFrame(traj, columns=[&#39;S&#39;, &#39;E&#39;, &#39;ES&#39;, &#39;P&#39;]) . We&#39;ll also write down Euler&#39;s method for the Michaelis-Menten/Briggs-Haldane kinetics . def euler_MM(E_0, S_0, dt, steps, **kinetic_params): S = S_0 E = E_0 P = 0 # k_on, k_off, k_cat, k_uncat, k_ms, k_mp = **kinetic_params traj = [[S, P]] for _ in range(int(steps)): dPdt = ((k_cat * E * S) / k_ms - (k_off * E * P) / k_mp) / (1 + S / k_ms + P / k_mp) dSdt = -dPdt P += dPdt * dt S += dSdt * dt traj.append([S, P]) return pd.DataFrame(traj, columns=[&#39;S_MM&#39;, &#39;P_MM&#39;]) . In order to produce a trajectory, we need to set initial conditions. We&#39;ll integrate the reaction kinetics of a hypothetical in vitro experiment, in which enzyme and substrate are added to the reaction at the outset. . $[E]_0$, the initial enzyme concentration, is set to 1 miliMolar (mM), i.e. 1000μM. | $[S]_0$, the initial substrate concentration is set to 5.5 mM, the typical concentration of glucose in the blood. | . E_0 = 1e3 S_0 = 5.5e3 . In vivo we would expect the concetration of enzyme to vary over time, and the substrate to be replenished. . We also need to set the step size for our numerical integration, and the number of steps: . dt = 1e-6 steps = 1e5 . traj_full = euler_full(E_0, S_0, dt, steps, **kinetic_params) traj_mm = euler_MM(E_0, S_0, dt, steps, **kinetic_params) . # figure styles def fig_style(ax): for side in [&quot;right&quot;,&quot;top&quot;]: ax.spines[side].set_visible(False) ax.set_xlabel(&#39;time (s)&#39;, weight=&#39;bold&#39;) ax.set_ylabel(&#39;concentration (μM)&#39;, weight=&#39;bold&#39;) def param_string(**kinetic_params): return f&#39;[k_on= {k_on}/μM/s] [k_off = {k_off}/s] [k_cat = {k_cat}/s] [k_uncat = {k_uncat}/μM/s] [E₀ = {int(E_0)}μM] [S₀ = {int(S_0)}μM]&#39; c = { &#39;S&#39;: &#39;dodgerblue&#39;, &#39;E&#39;: &#39;sienna&#39;, &#39;ES&#39;: &#39;blue&#39;, &#39;P&#39;: &#39;darkblue&#39;, &#39;S_MM&#39;: &#39;steelblue&#39;, &#39;P_MM&#39;: &#39;slateblue&#39;} def color(df): return [c[col] for col in df.columns] . ax = traj_full.plot.line(title=param_string(**kinetic_params), color=color(traj_full)) traj_mm.plot.line(ax=ax, color=color(traj_mm), linestyle=&#39;--&#39;) fig_style(ax) . We can plainly see the validity of the Quasi-Steady-State Approximation (QSSA) in action in the trajectory: Enzyme E and Substrate S rapidly form Enzyme-Substrate complex ES, which remains relatively constant throughout the course of the reaction. . cmap = plt.get_cmap(&quot;tab10&quot;) params = f&#39;[k_on= ? /μM x s] [k_off = ? /s] [k_cat = ? /s] [k_uncat = ? /μM x s] [E₀ = ? μM] [S₀ = ? μM]&#39; obs = traj[&#39;P&#39;][traj[&#39;P&#39;].index % 10000 == 0] obs.plot.line(title=params, marker=&#39;o&#39;, lw=0.1, color=cmap(3), ylim=(-300, 5800), legend=True) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x13052fd50&gt; . &lt;Mention that we see this kind of curve and fit the parameters, but usually we&#39;re varying concentration, not observing a timeseries&gt; . This appears to be a good moment to test the validity of the Michaelis-Menten expressions when the required assumptions are invalid. . Violating the Michaelis-Menten/Briggs-Haldane Assumptions . Enzyme/Substrate Concentration Ratio Assumption . E = 5.5e3 S = 5.5e3 dt = 1e-6 steps = 1e5 traj = pd.DataFrame(integrate_full(E, S, dt, steps), columns=[&#39;S&#39;, &#39;E&#39;, &#39;ES&#39;, &#39;P&#39;, &#39;P_MM&#39;]) . params = f&#39;[k_on= {k_on}/μM x s] [k_off = {k_off}/s] [k_cat = {k_cat}/s] [k_uncat = {k_uncat}/μM x s] [E₀ = {int(E)}μM] [S₀ = {int(S)}μM]&#39; traj.plot.line(title=params) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x139b14790&gt; . Quasi-Steady-State Approximation (QSSA) . ES takes a while to equilibrate . E = 5.5e3 S = 5.5e3 dt = 1e-6 steps = 1e5 k_on = 0.1 # in micromolar k_off = 10 # in 1/s k_cat = 100 # in 1/s k_uncat = 0.1 # in micromolar kms = (k_off + k_cat) / k_on kmp = (k_off + k_cat) / k_uncat kms, kmp traj = pd.DataFrame(integrate_full(E, S, dt, steps, k_on=k_on, k_off=k_off, k_cat=k_cat, k_uncat=k_uncat), columns=[&#39;S&#39;, &#39;E&#39;, &#39;ES&#39;, &#39;P&#39;, &#39;P_MM&#39;]) . params = f&#39;[k_on= {k_on}/μM x s] [k_off = {k_off}/s] [k_cat = {k_cat}/s] [k_uncat = {k_uncat}/μM x s] [E₀ = {int(E)}μM] [S₀ = {int(S)}μM]&#39; traj.plot.line(title=params) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x13d5f63d0&gt; . 3. Inference . Now let&#39;s use MCMC to get a posterior over $ kcat$, $ kuncat$, $K_{m, mathrm{S}}$, and $K_{m, mathrm{P}}$ (from which we can derive $ kon ,$ and $ koff$ ) using the Michaelis Menten Kinetics expression for dPdt. The likelihood is a gaussian around the observed concentration of P, sampled densely in time. . 2.1 Basic . Need to spend some time defining decent priors . # if kon is 1 micromolar, and affinities can range from nanomolar to milimolar, then k_off must be between 1e-3 and 1e3. lognormal # kon between 5e5 and 5e6 mean at 1e6, lognormal # kuncat zero to 1e6, lognormal, mean at 1e2 # KM lies between 10^-1 and 10^-7 M scipy.stats.lognorm? . params = np.array([kms, kmp, k_cat, k_off]) prior_cov = np.eye(4) * params/3 prior = multivariate_normal(mean=params, cov=prior_cov) observational_noise = 1 likelihood_dist = multivariate_normal(mean=obs.values, cov=np.eye(len(obs)) * observational_noise) observed_idx = obs.index.astype(int) def MH_MCMC(chain_length=1e3): zt = prior.rvs() ut = integrate_MM(zt)[&#39;P&#39;] πt = -likelihood_dist.logpdf(ut.loc[observed_idx].values) #- prior.logpdf(zt) cov = prior_cov i = 0 accept_ratio = 0 chain = [] samples = [] while i &lt; chain_length: ztp1 = np.clip(np.random.multivariate_normal(zt, cov), 0, None) utp1 = integrate_MM(ztp1)[&#39;P&#39;] πtp1 = -likelihood_dist.logpdf(utp1.loc[observed_idx].values) #- prior.logpdf(zt) if πtp1 - πt &lt; -np.log(np.random.rand()): zt, ut, πt = ztp1, utp1, πtp1 accept_ratio += 1 chain.append(zt) samples.append(ut.values) i += 1 if i % 1e2 == 0 and i &gt; 0: cov = np.cov(np.array(chain), rowvar=False) print(i, end=&#39; r&#39;) return pd.DataFrame(chain, columns=[&#39;kms&#39;, &#39;kmp&#39;, &#39;k_cat&#39;, &#39;k_off&#39;]), pd.DataFrame(samples), accept_ratio/chain_length, cov . chain, samples, accept_ratio, cov = MH_MCMC() . 1000 . ax = chain.plot.line(ylim=(0, 2300), xlim=(0,1000), logy=True) for i, param in enumerate(params): ax.axhline(param, lw=0.5, color=cmap(i), linestyle=&#39;--&#39;) . /usr/local/lib/python3.7/site-packages/pandas/plotting/_matplotlib/core.py:479: UserWarning: Attempted to set non-positive bottom ylim on a log-scaled axis. Invalid limit will be ignored. ax.set_ylim(self.ylim) . params . array([ 200., 2000., 100., 100.]) . sns.pairplot(chain, kind=&quot;kde&quot;) . &lt;seaborn.axisgrid.PairGrid at 0x1372078d0&gt; . accept_ratio . 0.04 . pd.DataFrame(cov) . 0 1 2 3 . 0 2098.532183 | -997.484455 | 123.922103 | -1823.662515 | . 1 -997.484455 | 873.417648 | -123.266991 | 331.330642 | . 2 123.922103 | -123.266991 | 23.117602 | 14.054959 | . 3 -1823.662515 | 331.330642 | 14.054959 | 2684.146271 | . ax = obs.plot.line(marker=&#39;o&#39;, lw=0.1, color=cmap(3), ylim=(-300, 5800), legend=True) samples.loc[-100:][samples.columns[::50]].T.plot.line(color=&#39;orange&#39;, lw=0.1, ax=ax, legend=False) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x139049d90&gt; . chain.to_hdf(&#39;chain.hdf&#39;, &#39;chain1&#39;) samples.to_hdf(&#39;chain.hdf&#39;, &#39;samples1&#39;) . 3. References . A Database of Thermodynamic Quantities for the Reactions of Glycolysis and the Tricarboxylic Acid Cycle . | A database of thermodynamic properties of the reactions of glycolysis, the tricarboxylic acid cycle, and the pentose phosphate pathway . | . Thermodynamics of Glycolysis/III%3A_Reactivity_in_Organic_Biological_and_Inorganic_Chemistry_1/08%3A_Mechanisms_of_Glycolysis/8.08%3A_Thermodynamics_of_Glycolysis) | . BKMS-React database entry for glycolysis | . Bistability in Glycolysis Pathway as a Physiological Switch in Energy Metabolism | . Determination of the rate of hexokinase-glucose dissociation by the isotope-trapping method | . Quantitative Fundamentals of Molecular and Cellular Bioengineering | .",
            "url": "https://alexlenail.me/back_of_my_envelope/2021/01/14/Enzyme-Kinetic-Parameter-Inference.html",
            "relUrl": "/2021/01/14/Enzyme-Kinetic-Parameter-Inference.html",
            "date": " • Jan 14, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Enzyme Kinetic Parameter Inference",
            "content": "# imports from itertools import combinations_with_replacement, product from collections import Counter from io import StringIO import numpy as np import pandas as pd import matplotlib.pyplot as plt import matplotlib.ticker as mtick import scipy.stats import seaborn as sns from scipy.stats import multivariate_normal from scipy.interpolate import interp1d from scipy.stats.kde import gaussian_kde from sklearn.linear_model import LinearRegression from sklearn.gaussian_process.kernels import Matern import ipywidgets as widgets from IPython.display import display %config InlineBackend.figure_format = &#39;retina&#39; %matplotlib inline plt.rcParams[&#39;figure.figsize&#39;] = [12, 5] plt.rcParams[&#39;figure.dpi&#39;] = 140 plt.rcParams[&#39;agg.path.chunksize&#39;] = 10000 %load_ext jupyternotify import os # os.system(&quot;printf &#39; a&#39;&quot;) # or &#39; 7&#39; exp = np.exp sin = np.sin cos = np.cos sqrt = np.sqrt Π = np.prod π = np.pi N = np.random.normal def is_power_of_2(x): return x &gt; 4 and (x &amp; (x-1) == 0) . # simple matrix view macro import PIL.Image from matplotlib.pyplot import imshow def show(*Ms): fig, axs = plt.subplots(ncols=len(Ms)) for M, ax in zip(Ms, (axs if type(axs) == list else [axs])): M = np.atleast_2d(M) ax.imshow(PIL.Image.fromarray((M - M.min()) * 255 / M.max())) ax.set_xticks([0, M.shape[1]]) ax.set_yticks([0, M.shape[0]]) for side in [&quot;right&quot;,&quot;top&quot;,&quot;bottom&quot;,&quot;left&quot;]: ax.spines[side].set_visible(False) return fig, axs . # simple distrib pdf view macro from scipy.stats import weibull_min, dweibull, dgamma, expon as exponential from scipy.stats import rv_discrete, rv_continuous def is_discrete(dist): if hasattr(dist, &#39;dist&#39;): return isinstance(dist.dist, rv_discrete) else: return isinstance(dist, rv_discrete) def is_continuous(dist): if hasattr(dist, &#39;dist&#39;): return isinstance(dist.dist, rv_continuous) else: return isinstance(dist, rv_continuous) def plot_distrib(distrib, title=None): fig, ax = plt.subplots(1, 1) if is_continuous(distrib): x = np.linspace(distrib.ppf(0.01), distrib.ppf(0.99), 100) ax.plot(x, distrib.pdf(x), &#39;k-&#39;, lw=0.4) elif is_discrete(distrib): x = np.arange(distrib.ppf(0.01), distrib.ppf(0.99)) ax.plot(x, distrib.pmf(x), &#39;bo&#39;, ms=2, lw=0.4) r = distrib.rvs(size=1000) ax.hist(r, density=True, histtype=&#39;stepfilled&#39;, alpha=0.2, bins=100) if title: ax.set_title(title) return ax . Background . $$ newcommand{ kon}{k_{ mathrm{on}}} newcommand{ koff}{k_{ mathrm{off}}} newcommand{ kcat}{k_{ mathrm{cat}}} newcommand{ kuncat}{k_{ mathrm{uncat}}} newcommand{ dSdt}{ frac{d[ mathrm{S}]}{dt}} newcommand{ dEdt}{ frac{d[ mathrm{E}]}{dt}} newcommand{ dESdt}{ frac{d[ mathrm{ES}]}{dt}} newcommand{ dPdt}{ frac{d[ mathrm{P}]}{dt}}$$Chemical reactions in cells are catalyzed by enzymes, which confer rate accelerations to those reactions. Mathematical biologists seek to model enzyme-catalyzed chemical kinetics with differential equations. Consider the following formalism for enzymatically-catalyzed chemical reactions: . $$ E+S underset{ koff}{ overset{ kon}{ rightleftarrows}} ES underset{ kuncat}{ overset{ kcat}{ rightleftarrows}}E+P $$ . In this scheme E is an enzyme, S is its substrate, ES is the enzyme-substrate complex, which is an intermediate, and P is the product of the reaction. Each of those chemical species has a concentration in a fixed volume, which we denote with brackets (e.g. [E]). Four reactions are included: enzyme-substrate association, dissociation, enzyme catalysis of substrate into product, and enzyme-product re-association (uncatalysis). Each reaction has a linear rate in the concentrations with associated rate constants: $k_{ mathrm{on}}$, $k_{ mathrm{off}}$, $k_{ mathrm{cat}}$, $k_{ mathrm{uncat}}$ which comprise the 4 degrees of freedom in our kinetics. The &#39;direction&#39; of the reaction, and the designation of &#39;substrate&#39; and &#39;product&#39; is our choice -- the model is entirely symmetric, which is reflected in the associated ODEs: . $$ begin{aligned} frac{d[ mathrm{S}]}{dt} &amp;= k_{ mathrm{off}}[ mathrm{ES}] - k_{ mathrm{on}}[ mathrm{E}][ mathrm{S}] frac{d[ mathrm{E}]}{dt} &amp;= k_{ mathrm{off}}[ mathrm{ES}] - k_{ mathrm{on}}[ mathrm{E}][ mathrm{S}] + k_{ mathrm{cat}}[ mathrm{ES}] - k_{ mathrm{uncat}}[ mathrm{E}][ mathrm{P}] frac{d[ mathrm{ES}]}{dt} &amp;= - k_{ mathrm{off}}[ mathrm{ES}] + k_{ mathrm{on}}[ mathrm{E}][ mathrm{S}] - k_{ mathrm{cat}}[ mathrm{ES}] + k_{ mathrm{uncat}}[ mathrm{E}][ mathrm{P}] frac{d[ mathrm{P}]}{dt} &amp;= k_{ mathrm{cat}}[ mathrm{ES}] - k_{ mathrm{uncat}}[ mathrm{E}][ mathrm{P}] end{aligned}$$The assumption made to derive these equations is that the molecular species are &#39;well-mixed&#39; in solution, permitting us to invoke the &#39;Law of Mass Action&#39;. We note here that the intracellular environment is not best described as well-mixed, and models of &#39;Macromolecular Crowding&#39; have led to more accurate rate laws for these reactions in vivo. However, we will retain the well-mixed assumption in this work. . We are typically most interested in integrating $ frac{d[ mathrm{P}]}{dt}$. . An assumption commonly made at this point is to suppose that the rates of enzyme-substrate association ($ kon$) and dissociation ($ koff$) are greater than those for the enzyme and product ($ kon$, $ koff$ $ gg$ $ kcat$, $ kuncat$). Under that assumption, and assuming the initial substrate concentration is much larger than the enzyme concentration ($[ mathrm{S_0}] &gt; [ mathrm{E_0}]$), a timescale separation argument called the &quot;Quasi-Steady-State Approximation&quot; (QSSA) permits us to set $ dESdt = 0$. From this approximation, we can derive footnote{A good Reversible Michaelis-Menten/Briggs-Haldane derivation can be found here the traditional Reversible Michaelis-Menten/Briggs-Haldane expression: . $$ frac{d[ mathrm{P}]}{dt} = frac{ frac{ kcat , [ mathrm{E_T}] [ mathrm{S}]}{K_{m, mathrm{S}}} - frac{ kuncat , [ mathrm{E_T}] [ mathrm{P}]}{K_{m, mathrm{P}}}} {1+ frac{[ mathrm{S}]}{K_{m, mathrm{S}}} + frac{[ mathrm{P}]}{K_{m, mathrm{P}}}}$$in which we have introduced the &quot;Michaelis Constants&quot;: $K_{m, mathrm{S}} = frac{ koff + kcat}{ kon}$ and $K_{m, mathrm{P}} = frac{ kcat + koff}{ kuncat}$. The determination of the 4 constants ($ kcat$, $ kuncat$, $K_{m, mathrm{S}}$, and $K_{m, mathrm{P}}$) from experimental data for the enzymatic reactions of life is a major project, and reported values have been tabulated in the BRENDA database. . 1. Simulation . # define integrate_full k_on = 1 k_off = 100 k_cat = 100 k_uncat = 0.1 def integrate_full(E, S, dt, steps, k_on=k_on, k_off=k_off, k_cat=k_cat, k_uncat=k_uncat): S = S E_T = E ES = 0 P = 0 P2 = 0 traj = [[S, E, ES, P, P2]] for _ in range(int(steps)): dSdt = k_off * ES - k_on * E * S dEdt = k_off * ES - k_on * E * S + k_cat * ES - k_uncat * E * P dESdt = k_on * E * S - k_off * ES - k_cat * ES + k_uncat * E * P dPdt = k_cat * ES - k_uncat * E * P dP2dt = ((k_cat * E_T * S) / kms - (k_off * E_T * P) / kmp) / (1 + S / kms + P / kmp) S += dSdt * dt E += dEdt * dt ES += dESdt * dt P += dPdt * dt P2 += dP2dt * dt traj.append([S, E, ES, P, P2]) return traj . E = 1e3 S = 5.5e3 dt = 1e-6 steps = 1e5 traj = pd.DataFrame(integrate_full(E, S, dt, steps), columns=[&#39;S&#39;, &#39;E&#39;, &#39;ES&#39;, &#39;P&#39;, &#39;P_MM&#39;]) . params = f&#39;[k_on= {k_on}/μM x s] [k_off = {k_off}/s] [k_cat = {k_cat}/s] [k_uncat = {k_uncat}/μM x s] [E₀ = {int(E)}μM] [S₀ = {int(S)}μM]&#39; traj.plot.line(title=params) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x1394c4890&gt; . cmap = plt.get_cmap(&quot;tab10&quot;) params = f&#39;[k_on= ? /μM x s] [k_off = ? /s] [k_cat = ? /s] [k_uncat = ? /μM x s] [E₀ = ? μM] [S₀ = ? μM]&#39; obs = traj[&#39;P&#39;][traj[&#39;P&#39;].index % 10000 == 0] obs.plot.line(title=params, marker=&#39;o&#39;, lw=0.1, color=cmap(3), ylim=(-300, 5800), legend=True) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x13052fd50&gt; . def integrate_MM(zt, dt=dt, steps=steps, E_T=1e3, S_0=5.5e3): kms, kmp, k_cat, k_off = zt S = S_0 E_T = E_T P = 0 traj = [[S, P]] for _ in range(int(steps)): dPdt = ((k_cat * E_T * S) / kms - (k_off * E_T * P) / kmp) / (1 + S / kms + P / kmp) dSdt = -dPdt S += dSdt * dt P += dPdt * dt traj.append([S, P]) return pd.DataFrame(traj, columns=[&#39;S&#39;, &#39;P&#39;]) . k_on = 1 # in micromolar k_off = 100 # in 1/s k_cat = 100 # in 1/s k_uncat = 0.1 # in micromolar kms = (k_off + k_cat) / k_on kmp = (k_off + k_cat) / k_uncat # koff = kmp * kuncat - kcat # kon = (koff + kcat) / kms kms, kmp . (200.0, 2000.0) . 2. Inference . 2.1 Basic . # if kon is 1 micromolar, and affinities can range from nanomolar to milimolar, then k_off must be between 1e-3 and 1e3. lognormal # kon between 5e5 and 5e6 mean at 1e6, lognormal # kuncat zero to 1e6, lognormal, mean at 1e2 # KM lies between 10^-1 and 10^-7 M scipy.stats.lognorm? . params = np.array([kms, kmp, k_cat, k_off]) prior_cov = np.eye(4) * params/3 prior = multivariate_normal(mean=params, cov=prior_cov) observational_noise = 1 likelihood_dist = multivariate_normal(mean=obs.values, cov=np.eye(len(obs)) * observational_noise) observed_idx = obs.index.astype(int) def MH_MCMC(chain_length=1e3): zt = prior.rvs() ut = integrate_MM(zt)[&#39;P&#39;] πt = -likelihood_dist.logpdf(ut.loc[observed_idx].values) #- prior.logpdf(zt) cov = prior_cov i = 0 accept_ratio = 0 chain = [] samples = [] while i &lt; chain_length: ztp1 = np.clip(np.random.multivariate_normal(zt, cov), 0, None) utp1 = integrate_MM(ztp1)[&#39;P&#39;] πtp1 = -likelihood_dist.logpdf(utp1.loc[observed_idx].values) #- prior.logpdf(zt) if πtp1 - πt &lt; -np.log(np.random.rand()): zt, ut, πt = ztp1, utp1, πtp1 accept_ratio += 1 chain.append(zt) samples.append(ut.values) i += 1 if i % 1e2 == 0 and i &gt; 0: cov = np.cov(np.array(chain), rowvar=False) print(i, end=&#39; r&#39;) return pd.DataFrame(chain, columns=[&#39;kms&#39;, &#39;kmp&#39;, &#39;k_cat&#39;, &#39;k_off&#39;]), pd.DataFrame(samples), accept_ratio/chain_length, cov . chain, samples, accept_ratio, cov = MH_MCMC() . 1000 . ax = chain.plot.line(ylim=(0, 2300), xlim=(0,1000), logy=True) for i, param in enumerate(params): ax.axhline(param, lw=0.5, color=cmap(i), linestyle=&#39;--&#39;) . /usr/local/lib/python3.7/site-packages/pandas/plotting/_matplotlib/core.py:479: UserWarning: Attempted to set non-positive bottom ylim on a log-scaled axis. Invalid limit will be ignored. ax.set_ylim(self.ylim) . params . array([ 200., 2000., 100., 100.]) . sns.pairplot(chain, kind=&quot;kde&quot;) . &lt;seaborn.axisgrid.PairGrid at 0x1372078d0&gt; . accept_ratio . 0.04 . pd.DataFrame(cov) . 0 1 2 3 . 0 2098.532183 | -997.484455 | 123.922103 | -1823.662515 | . 1 -997.484455 | 873.417648 | -123.266991 | 331.330642 | . 2 123.922103 | -123.266991 | 23.117602 | 14.054959 | . 3 -1823.662515 | 331.330642 | 14.054959 | 2684.146271 | . ax = obs.plot.line(marker=&#39;o&#39;, lw=0.1, color=cmap(3), ylim=(-300, 5800), legend=True) samples.loc[-100:][samples.columns[::50]].T.plot.line(color=&#39;orange&#39;, lw=0.1, ax=ax, legend=False) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x139049d90&gt; . chain.to_hdf(&#39;chain.hdf&#39;, &#39;chain1&#39;) samples.to_hdf(&#39;chain.hdf&#39;, &#39;samples1&#39;) . 2.2 Enzyme/Substrate Concentration Ratio Assumption . E = 5.5e3 S = 5.5e3 dt = 1e-6 steps = 1e5 traj = pd.DataFrame(integrate_full(E, S, dt, steps), columns=[&#39;S&#39;, &#39;E&#39;, &#39;ES&#39;, &#39;P&#39;, &#39;P_MM&#39;]) . params = f&#39;[k_on= {k_on}/μM x s] [k_off = {k_off}/s] [k_cat = {k_cat}/s] [k_uncat = {k_uncat}/μM x s] [E₀ = {int(E)}μM] [S₀ = {int(S)}μM]&#39; traj.plot.line(title=params) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x139b14790&gt; . 2.3 Quasi-Steady-State Approximation (QSSA) . ES takes a while to equilibrate . E = 5.5e3 S = 5.5e3 dt = 1e-6 steps = 1e5 k_on = 0.1 # in micromolar k_off = 10 # in 1/s k_cat = 100 # in 1/s k_uncat = 0.1 # in micromolar kms = (k_off + k_cat) / k_on kmp = (k_off + k_cat) / k_uncat kms, kmp traj = pd.DataFrame(integrate_full(E, S, dt, steps, k_on=k_on, k_off=k_off, k_cat=k_cat, k_uncat=k_uncat), columns=[&#39;S&#39;, &#39;E&#39;, &#39;ES&#39;, &#39;P&#39;, &#39;P_MM&#39;]) . params = f&#39;[k_on= {k_on}/μM x s] [k_off = {k_off}/s] [k_cat = {k_cat}/s] [k_uncat = {k_uncat}/μM x s] [E₀ = {int(E)}μM] [S₀ = {int(S)}μM]&#39; traj.plot.line(title=params) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x13d5f63d0&gt; . 3. References . A Database of Thermodynamic Quantities for the Reactions of Glycolysis and the Tricarboxylic Acid Cycle . | A database of thermodynamic properties of the reactions of glycolysis, the tricarboxylic acid cycle, and the pentose phosphate pathway . | . Thermodynamics of Glycolysis/III%3A_Reactivity_in_Organic_Biological_and_Inorganic_Chemistry_1/08%3A_Mechanisms_of_Glycolysis/8.08%3A_Thermodynamics_of_Glycolysis) | . BKMS-React database entry for glycolysis | . Bistability in Glycolysis Pathway as a Physiological Switch in Energy Metabolism | . Determination of the rate of hexokinase-glucose dissociation by the isotope-trapping method | . Quantitative Fundamentals of Molecular and Cellular Bioengineering | .",
            "url": "https://alexlenail.me/back_of_my_envelope/2021/01/01/Enzyme-Kinetic-Parameter-Inference.html",
            "relUrl": "/2021/01/01/Enzyme-Kinetic-Parameter-Inference.html",
            "date": " • Jan 1, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "Orthogonal Functions",
            "content": "# imports import numpy as np import pandas as pd import matplotlib.pyplot as plt import scipy.stats %matplotlib inline plt.rcParams[&#39;figure.figsize&#39;] = [12, 5] plt.rcParams[&#39;figure.dpi&#39;] = 140 π = np.pi exp = np.exp sin = np.sin cos = np.cos sqrt = np.sqrt . Fourier Basis . grid = 200 domain = [0, 2*π] dx = (domain[1]-domain[0])/grid grid = np.linspace(*domain, grid) def fourier(k, x): return sin(k*x)+cos(k*x) . n = 5 basis = pd.DataFrame({k: fourier(k, grid) for k in range(1,n)}, index=grid) ax = basis.plot.line(lw=0.4, xlim=domain) ax.axhline(0, c=&#39;black&#39;, lw=&#39;0.3&#39;) . &lt;matplotlib.lines.Line2D at 0x136a4e890&gt; . from scipy import integrate def compare_two(i, j): product = pd.Series(basis[i]*basis[j], name=&#39;product&#39;) product = pd.DataFrame([basis[i], basis[j], product]).T ax = product.plot.line(lw=0.5, color=[&#39;red&#39;, &#39;blue&#39;, &#39;purple&#39;]) ax.fill_between(grid, product[&#39;product&#39;], alpha=0.1) return integrate.trapz(product[&#39;product&#39;], x=product.index) . print(&#39;integral =&#39;, np.round(compare_two(3,4), 4)) . integral = -0.0 . &quot;fourier modes as eigenfunctions of the derivative operator&quot; What? . Polynomial Bases .",
            "url": "https://alexlenail.me/back_of_my_envelope/2020/12/04/orthogonal-functions.html",
            "relUrl": "/2020/12/04/orthogonal-functions.html",
            "date": " • Dec 4, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About",
          "content": "",
          "url": "https://alexlenail.me/back_of_my_envelope/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
      ,"page3": {
          "title": "Old Blog",
          "content": "",
          "url": "https://alexlenail.me/back_of_my_envelope/old/",
          "relUrl": "/old/",
          "date": ""
      }
      
  

  
  

  
  

  
  

  
      ,"page7": {
          "title": "",
          "content": "{“/about/”:”http://alexlenail.me”,”/old/”:”https://alexlenail.medium.com/”} .",
          "url": "https://alexlenail.me/back_of_my_envelope/redirects.json",
          "relUrl": "/redirects.json",
          "date": ""
      }
      
  

  
  

  
      ,"page9": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://alexlenail.me/back_of_my_envelope/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

  
  

}