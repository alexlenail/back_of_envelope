{
  
    
        "post0": {
            "title": "Enzyme Kinetic Parameter Inference",
            "content": "# imports from itertools import combinations_with_replacement, product from collections import Counter from io import StringIO import numpy as np import pandas as pd import matplotlib.pyplot as plt import matplotlib.ticker as mtick import scipy.stats import seaborn as sns from scipy.stats import multivariate_normal from scipy.interpolate import interp1d from scipy.stats.kde import gaussian_kde from sklearn.linear_model import LinearRegression from sklearn.gaussian_process.kernels import Matern import ipywidgets as widgets from IPython.display import display %config InlineBackend.figure_format = &#39;retina&#39; %matplotlib inline plt.rcParams[&#39;figure.figsize&#39;] = [12, 5] plt.rcParams[&#39;figure.dpi&#39;] = 140 plt.rcParams[&#39;agg.path.chunksize&#39;] = 10000 %load_ext jupyternotify import os # os.system(&quot;printf &#39; a&#39;&quot;) # or &#39; 7&#39; exp = np.exp sin = np.sin cos = np.cos sqrt = np.sqrt Π = np.prod π = np.pi N = np.random.normal def is_power_of_2(x): return x &gt; 4 and (x &amp; (x-1) == 0) . # simple matrix view macro import PIL.Image from matplotlib.pyplot import imshow def show(*Ms): fig, axs = plt.subplots(ncols=len(Ms)) for M, ax in zip(Ms, (axs if type(axs) == list else [axs])): M = np.atleast_2d(M) ax.imshow(PIL.Image.fromarray((M - M.min()) * 255 / M.max())) ax.set_xticks([0, M.shape[1]]) ax.set_yticks([0, M.shape[0]]) for side in [&quot;right&quot;,&quot;top&quot;,&quot;bottom&quot;,&quot;left&quot;]: ax.spines[side].set_visible(False) return fig, axs . # simple distrib pdf view macro from scipy.stats import weibull_min, dweibull, dgamma, expon as exponential from scipy.stats import rv_discrete, rv_continuous def is_discrete(dist): if hasattr(dist, &#39;dist&#39;): return isinstance(dist.dist, rv_discrete) else: return isinstance(dist, rv_discrete) def is_continuous(dist): if hasattr(dist, &#39;dist&#39;): return isinstance(dist.dist, rv_continuous) else: return isinstance(dist, rv_continuous) def plot_distrib(distrib, title=None): fig, ax = plt.subplots(1, 1) if is_continuous(distrib): x = np.linspace(distrib.ppf(0.01), distrib.ppf(0.99), 100) ax.plot(x, distrib.pdf(x), &#39;k-&#39;, lw=0.4) elif is_discrete(distrib): x = np.arange(distrib.ppf(0.01), distrib.ppf(0.99)) ax.plot(x, distrib.pmf(x), &#39;bo&#39;, ms=2, lw=0.4) r = distrib.rvs(size=1000) ax.hist(r, density=True, histtype=&#39;stepfilled&#39;, alpha=0.2, bins=100) if title: ax.set_title(title) return ax . Background . $$ newcommand{ kon}{k_{ mathrm{on}}} newcommand{ koff}{k_{ mathrm{off}}} newcommand{ kcat}{k_{ mathrm{cat}}} newcommand{ kuncat}{k_{ mathrm{uncat}}} newcommand{ dSdt}{ frac{d[ mathrm{S}]}{dt}} newcommand{ dEdt}{ frac{d[ mathrm{E}]}{dt}} newcommand{ dESdt}{ frac{d[ mathrm{ES}]}{dt}} newcommand{ dPdt}{ frac{d[ mathrm{P}]}{dt}}$$Chemical reactions in cells are catalyzed by enzymes, which confer rate accelerations to those reactions. Mathematical biologists seek to model enzyme-catalyzed chemical kinetics with differential equations. Consider the following formalism for enzymatically-catalyzed chemical reactions: . $$ E+S underset{ koff}{ overset{ kon}{ rightleftarrows}} ES underset{ kuncat}{ overset{ kcat}{ rightleftarrows}}E+P $$ . In this scheme E is an enzyme, S is its substrate, ES is the enzyme-substrate complex, which is an intermediate, and P is the product of the reaction. Each of those chemical species has a concentration in a fixed volume, which we denote with brackets (e.g. [E]). Four reactions are included: enzyme-substrate association, dissociation, enzyme catalysis of substrate into product, and enzyme-product re-association (uncatalysis). Each reaction has a linear rate in the concentrations with associated rate constants: $k_{ mathrm{on}}$, $k_{ mathrm{off}}$, $k_{ mathrm{cat}}$, $k_{ mathrm{uncat}}$ which comprise the 4 degrees of freedom in our kinetics. The &#39;direction&#39; of the reaction, and the designation of &#39;substrate&#39; and &#39;product&#39; is our choice -- the model is entirely symmetric, which is reflected in the associated ODEs: . $$ begin{aligned} frac{d[ mathrm{S}]}{dt} &amp;= k_{ mathrm{off}}[ mathrm{ES}] - k_{ mathrm{on}}[ mathrm{E}][ mathrm{S}] frac{d[ mathrm{E}]}{dt} &amp;= k_{ mathrm{off}}[ mathrm{ES}] - k_{ mathrm{on}}[ mathrm{E}][ mathrm{S}] + k_{ mathrm{cat}}[ mathrm{ES}] - k_{ mathrm{uncat}}[ mathrm{E}][ mathrm{P}] frac{d[ mathrm{ES}]}{dt} &amp;= - k_{ mathrm{off}}[ mathrm{ES}] + k_{ mathrm{on}}[ mathrm{E}][ mathrm{S}] - k_{ mathrm{cat}}[ mathrm{ES}] + k_{ mathrm{uncat}}[ mathrm{E}][ mathrm{P}] frac{d[ mathrm{P}]}{dt} &amp;= k_{ mathrm{cat}}[ mathrm{ES}] - k_{ mathrm{uncat}}[ mathrm{E}][ mathrm{P}] end{aligned}$$The assumption made to derive these equations is that the molecular species are &#39;well-mixed&#39; in solution, permitting us to invoke the &#39;Law of Mass Action&#39;. We note here that the intracellular environment is not best described as well-mixed, and models of &#39;Macromolecular Crowding&#39; have led to more accurate rate laws for these reactions in vivo. However, we will retain the well-mixed assumption in this work. . We are typically most interested in integrating $ frac{d[ mathrm{P}]}{dt}$. . An assumption commonly made at this point is to suppose that the rates of enzyme-substrate association ($ kon$) and dissociation ($ koff$) are greater than those for the enzyme and product ($ kon$, $ koff$ $ gg$ $ kcat$, $ kuncat$). Under that assumption, and assuming the initial substrate concentration is much larger than the enzyme concentration ($[ mathrm{S_0}] &gt; [ mathrm{E_0}]$), a timescale separation argument called the &quot;Quasi-Steady-State Approximation&quot; (QSSA) permits us to set $ dESdt = 0$. From this approximation, we can derive footnote{A good Reversible Michaelis-Menten/Briggs-Haldane derivation can be found here the traditional Reversible Michaelis-Menten/Briggs-Haldane expression: . $$ frac{d[ mathrm{P}]}{dt} = frac{ frac{ kcat , [ mathrm{E_T}] [ mathrm{S}]}{K_{m, mathrm{S}}} - frac{ kuncat , [ mathrm{E_T}] [ mathrm{P}]}{K_{m, mathrm{P}}}} {1+ frac{[ mathrm{S}]}{K_{m, mathrm{S}}} + frac{[ mathrm{P}]}{K_{m, mathrm{P}}}}$$in which we have introduced the &quot;Michaelis Constants&quot;: $K_{m, mathrm{S}} = frac{ koff + kcat}{ kon}$ and $K_{m, mathrm{P}} = frac{ kcat + koff}{ kuncat}$. The determination of the 4 constants ($ kcat$, $ kuncat$, $K_{m, mathrm{S}}$, and $K_{m, mathrm{P}}$) from experimental data for the enzymatic reactions of life is a major project, and reported values have been tabulated in the BRENDA database. . 1. Simulation . # define integrate_full k_on = 1 k_off = 100 k_cat = 100 k_uncat = 0.1 def integrate_full(E, S, dt, steps, k_on=k_on, k_off=k_off, k_cat=k_cat, k_uncat=k_uncat): S = S E_T = E ES = 0 P = 0 P2 = 0 traj = [[S, E, ES, P, P2]] for _ in range(int(steps)): dSdt = k_off * ES - k_on * E * S dEdt = k_off * ES - k_on * E * S + k_cat * ES - k_uncat * E * P dESdt = k_on * E * S - k_off * ES - k_cat * ES + k_uncat * E * P dPdt = k_cat * ES - k_uncat * E * P dP2dt = ((k_cat * E_T * S) / kms - (k_off * E_T * P) / kmp) / (1 + S / kms + P / kmp) S += dSdt * dt E += dEdt * dt ES += dESdt * dt P += dPdt * dt P2 += dP2dt * dt traj.append([S, E, ES, P, P2]) return traj . E = 1e3 S = 5.5e3 dt = 1e-6 steps = 1e5 traj = pd.DataFrame(integrate_full(E, S, dt, steps), columns=[&#39;S&#39;, &#39;E&#39;, &#39;ES&#39;, &#39;P&#39;, &#39;P_MM&#39;]) . params = f&#39;[k_on= {k_on}/μM x s] [k_off = {k_off}/s] [k_cat = {k_cat}/s] [k_uncat = {k_uncat}/μM x s] [E₀ = {int(E)}μM] [S₀ = {int(S)}μM]&#39; traj.plot.line(title=params) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x1394c4890&gt; . cmap = plt.get_cmap(&quot;tab10&quot;) params = f&#39;[k_on= ? /μM x s] [k_off = ? /s] [k_cat = ? /s] [k_uncat = ? /μM x s] [E₀ = ? μM] [S₀ = ? μM]&#39; obs = traj[&#39;P&#39;][traj[&#39;P&#39;].index % 10000 == 0] obs.plot.line(title=params, marker=&#39;o&#39;, lw=0.1, color=cmap(3), ylim=(-300, 5800), legend=True) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x13052fd50&gt; . def integrate_MM(zt, dt=dt, steps=steps, E_T=1e3, S_0=5.5e3): kms, kmp, k_cat, k_off = zt S = S_0 E_T = E_T P = 0 traj = [[S, P]] for _ in range(int(steps)): dPdt = ((k_cat * E_T * S) / kms - (k_off * E_T * P) / kmp) / (1 + S / kms + P / kmp) dSdt = -dPdt S += dSdt * dt P += dPdt * dt traj.append([S, P]) return pd.DataFrame(traj, columns=[&#39;S&#39;, &#39;P&#39;]) . k_on = 1 # in micromolar k_off = 100 # in 1/s k_cat = 100 # in 1/s k_uncat = 0.1 # in micromolar kms = (k_off + k_cat) / k_on kmp = (k_off + k_cat) / k_uncat # koff = kmp * kuncat - kcat # kon = (koff + kcat) / kms kms, kmp . (200.0, 2000.0) . 2. Inference . 2.1 Basic . # if kon is 1 micromolar, and affinities can range from nanomolar to milimolar, then k_off must be between 1e-3 and 1e3. lognormal # kon between 5e5 and 5e6 mean at 1e6, lognormal # kuncat zero to 1e6, lognormal, mean at 1e2 # KM lies between 10^-1 and 10^-7 M scipy.stats.lognorm? . params = np.array([kms, kmp, k_cat, k_off]) prior_cov = np.eye(4) * params/3 prior = multivariate_normal(mean=params, cov=prior_cov) observational_noise = 1 likelihood_dist = multivariate_normal(mean=obs.values, cov=np.eye(len(obs)) * observational_noise) observed_idx = obs.index.astype(int) def MH_MCMC(chain_length=1e3): zt = prior.rvs() ut = integrate_MM(zt)[&#39;P&#39;] πt = -likelihood_dist.logpdf(ut.loc[observed_idx].values) #- prior.logpdf(zt) cov = prior_cov i = 0 accept_ratio = 0 chain = [] samples = [] while i &lt; chain_length: ztp1 = np.clip(np.random.multivariate_normal(zt, cov), 0, None) utp1 = integrate_MM(ztp1)[&#39;P&#39;] πtp1 = -likelihood_dist.logpdf(utp1.loc[observed_idx].values) #- prior.logpdf(zt) if πtp1 - πt &lt; -np.log(np.random.rand()): zt, ut, πt = ztp1, utp1, πtp1 accept_ratio += 1 chain.append(zt) samples.append(ut.values) i += 1 if i % 1e2 == 0 and i &gt; 0: cov = np.cov(np.array(chain), rowvar=False) print(i, end=&#39; r&#39;) return pd.DataFrame(chain, columns=[&#39;kms&#39;, &#39;kmp&#39;, &#39;k_cat&#39;, &#39;k_off&#39;]), pd.DataFrame(samples), accept_ratio/chain_length, cov . chain, samples, accept_ratio, cov = MH_MCMC() . 1000 . ax = chain.plot.line(ylim=(0, 2300), xlim=(0,1000), logy=True) for i, param in enumerate(params): ax.axhline(param, lw=0.5, color=cmap(i), linestyle=&#39;--&#39;) . /usr/local/lib/python3.7/site-packages/pandas/plotting/_matplotlib/core.py:479: UserWarning: Attempted to set non-positive bottom ylim on a log-scaled axis. Invalid limit will be ignored. ax.set_ylim(self.ylim) . params . array([ 200., 2000., 100., 100.]) . sns.pairplot(chain, kind=&quot;kde&quot;) . &lt;seaborn.axisgrid.PairGrid at 0x1372078d0&gt; . accept_ratio . 0.04 . pd.DataFrame(cov) . 0 1 2 3 . 0 2098.532183 | -997.484455 | 123.922103 | -1823.662515 | . 1 -997.484455 | 873.417648 | -123.266991 | 331.330642 | . 2 123.922103 | -123.266991 | 23.117602 | 14.054959 | . 3 -1823.662515 | 331.330642 | 14.054959 | 2684.146271 | . ax = obs.plot.line(marker=&#39;o&#39;, lw=0.1, color=cmap(3), ylim=(-300, 5800), legend=True) samples.loc[-100:][samples.columns[::50]].T.plot.line(color=&#39;orange&#39;, lw=0.1, ax=ax, legend=False) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x139049d90&gt; . chain.to_hdf(&#39;chain.hdf&#39;, &#39;chain1&#39;) samples.to_hdf(&#39;chain.hdf&#39;, &#39;samples1&#39;) . 2.2 Enzyme/Substrate Concentration Ratio Assumption . E = 5.5e3 S = 5.5e3 dt = 1e-6 steps = 1e5 traj = pd.DataFrame(integrate_full(E, S, dt, steps), columns=[&#39;S&#39;, &#39;E&#39;, &#39;ES&#39;, &#39;P&#39;, &#39;P_MM&#39;]) . params = f&#39;[k_on= {k_on}/μM x s] [k_off = {k_off}/s] [k_cat = {k_cat}/s] [k_uncat = {k_uncat}/μM x s] [E₀ = {int(E)}μM] [S₀ = {int(S)}μM]&#39; traj.plot.line(title=params) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x139b14790&gt; . 2.3 Quasi-Steady-State Approximation (QSSA) . ES takes a while to equilibrate . E = 5.5e3 S = 5.5e3 dt = 1e-6 steps = 1e5 k_on = 0.1 # in micromolar k_off = 10 # in 1/s k_cat = 100 # in 1/s k_uncat = 0.1 # in micromolar kms = (k_off + k_cat) / k_on kmp = (k_off + k_cat) / k_uncat kms, kmp traj = pd.DataFrame(integrate_full(E, S, dt, steps, k_on=k_on, k_off=k_off, k_cat=k_cat, k_uncat=k_uncat), columns=[&#39;S&#39;, &#39;E&#39;, &#39;ES&#39;, &#39;P&#39;, &#39;P_MM&#39;]) . params = f&#39;[k_on= {k_on}/μM x s] [k_off = {k_off}/s] [k_cat = {k_cat}/s] [k_uncat = {k_uncat}/μM x s] [E₀ = {int(E)}μM] [S₀ = {int(S)}μM]&#39; traj.plot.line(title=params) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x13d5f63d0&gt; . 3. References . A Database of Thermodynamic Quantities for the Reactions of Glycolysis and the Tricarboxylic Acid Cycle . | A database of thermodynamic properties of the reactions of glycolysis, the tricarboxylic acid cycle, and the pentose phosphate pathway . | . Thermodynamics of Glycolysis/III%3A_Reactivity_in_Organic_Biological_and_Inorganic_Chemistry_1/08%3A_Mechanisms_of_Glycolysis/8.08%3A_Thermodynamics_of_Glycolysis) | . BKMS-React database entry for glycolysis | . Bistability in Glycolysis Pathway as a Physiological Switch in Energy Metabolism | . Determination of the rate of hexokinase-glucose dissociation by the isotope-trapping method | . Quantitative Fundamentals of Molecular and Cellular Bioengineering | .",
            "url": "https://alexlenail.me/back_of_my_envelope/2021/01/01/Enzyme-Kinetic-Parameter-Inference.html",
            "relUrl": "/2021/01/01/Enzyme-Kinetic-Parameter-Inference.html",
            "date": " • Jan 1, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Orthogonal Functions",
            "content": "# imports import numpy as np import pandas as pd import matplotlib.pyplot as plt import scipy.stats %matplotlib inline plt.rcParams[&#39;figure.figsize&#39;] = [12, 5] plt.rcParams[&#39;figure.dpi&#39;] = 140 π = np.pi exp = np.exp sin = np.sin cos = np.cos sqrt = np.sqrt . Fourier Basis . grid = 200 domain = [0, 2*π] dx = (domain[1]-domain[0])/grid grid = np.linspace(*domain, grid) def fourier(k, x): return sin(k*x)+cos(k*x) . n = 5 basis = pd.DataFrame({k: fourier(k, grid) for k in range(1,n)}, index=grid) ax = basis.plot.line(lw=0.4, xlim=domain) ax.axhline(0, c=&#39;black&#39;, lw=&#39;0.3&#39;) . &lt;matplotlib.lines.Line2D at 0x136a4e890&gt; . from scipy import integrate def compare_two(i, j): product = pd.Series(basis[i]*basis[j], name=&#39;product&#39;) product = pd.DataFrame([basis[i], basis[j], product]).T ax = product.plot.line(lw=0.5, color=[&#39;red&#39;, &#39;blue&#39;, &#39;purple&#39;]) ax.fill_between(grid, product[&#39;product&#39;], alpha=0.1) return integrate.trapz(product[&#39;product&#39;], x=product.index) . print(&#39;integral =&#39;, np.round(compare_two(3,4), 4)) . integral = -0.0 . &quot;fourier modes as eigenfunctions of the derivative operator&quot; What? . Polynomial Bases .",
            "url": "https://alexlenail.me/back_of_my_envelope/2020/12/04/orthogonal-functions.html",
            "relUrl": "/2020/12/04/orthogonal-functions.html",
            "date": " • Dec 4, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About",
          "content": "",
          "url": "https://alexlenail.me/back_of_my_envelope/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
      ,"page3": {
          "title": "Old Blog",
          "content": "",
          "url": "https://alexlenail.me/back_of_my_envelope/old/",
          "relUrl": "/old/",
          "date": ""
      }
      
  

  
  

  
  

  
  

  
      ,"page7": {
          "title": "",
          "content": "{“/about/”:”http://alexlenail.me”,”/old/”:”https://alexlenail.medium.com/”} .",
          "url": "https://alexlenail.me/back_of_my_envelope/redirects.json",
          "relUrl": "/redirects.json",
          "date": ""
      }
      
  

  
  

  
      ,"page9": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://alexlenail.me/back_of_my_envelope/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

  
  

}